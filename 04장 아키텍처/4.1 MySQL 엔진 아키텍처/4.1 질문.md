# 4.1 MySQL 엔진 아키텍처

## MySQL의 아키텍처와 Spring 의 레이어드 아키텍처와 유사한 점은 무엇인가요?

**첫번째, 레이어별로 관심사를 분리하여 느슨한 결합을 가져간다.**

스토리지 엔진은 핸들러 API를 제공하고, MySQL 엔진은 이러한 핸들러 API를 호출하는 구조이기 때문에 필요에 따라 스토리지 엔진이 달라질 수 있다.

또한 MySQL 엔진은 가장 핵심적인 쿼리를 분석하고 최적화하는 역할만 담당하고, 실제 디스크에 접근해 데이터를 읽고 쓰는 역할은 스토리지 엔진에게 위임한다.

이는 마치 Repository 패턴에서 나타나는 Repository와 DAO의 관계와 유사하다고 볼 수 있다.

**두번째, 하나의 요청에 대해 하나의 스레드를 할당해 처리한다.**
스프링에서는 하나의 Http Request에 대해 하나의 스레드를 할당해 처리한다.

컨트롤러 앞에서 인터셉터와 아규먼트 리졸버가 기본적인 요청의 유효성 검증을 처리하고, 컨트롤러는 요청을 처리할 주체에게 메시지를 전달한다.

MySQL 에서도 하나의 요청에 대해 하나의 사용자 스레드를 할당해 처리하기 때문에 유사하다고 볼 수 있다.

<br>

## MySQL에서 글로벌 메모리와 로컬 메모리 둘의 차이는?

글로벌 메모리와 로컬 메모리는 스레드가 공유하는지 여부에 따라 구분이 됩니다. 글로벌 메모리는 많은 스레드에 의해 공유되는 반면, 로컬 메모리는 클라이언트 요청으로 생성된 클라이언트 스레드 별로 생성되고 스레드 간에 공유가 되지 않습니다.

<br>

## MySQL 8.0부터는 기존의 플러그인 아키텍처 대신 컴포넌트 아키텍처로 변경이 되었다. 기존 플러그인 아키텍처의 단점은?

1. 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신 할수 없다.
2. 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않다.(캡슐화가 적용되지 않음)
3. 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움.

MySQL 에서도 하나의 요청에 대해 하나의 사용자 스레드를 할당해 처리하기 때문에 유사하다고 볼 수 있다.

<br>

## 12. 4 CPU 환경에서 4개의 쓰레드가 실행된다고 가정해보자. 어떤 문제가 발생할 수 있겠는가?

CPU Affinity 가 각 쓰레드에 대해 설정되어 있지 않다면 성능이 낮아질 수 있습니다. 예를 들어, 예전에 제가 KISTI 와 함께 진행했던 과제에서는 MPI 컨테이너 하나에서 여러 개의 프로세스를 생성해 HPC Job 을 처리하는 케이스가 있었는데 CPU Affinity 를 설정하지 않았을 때는 htop 명령어에서 CPU 사용량이 요동을 쳤던 것이 기억이 납니다. 마찬가지로 RT Benchmark 인 Cyclictest 에서도 여러 개의 쓰레드가 각 CPU 에 대해 exclusive 하게 사용하도록 설정했을 때가 성능이 가장 잘 나왔던 것으로 기억합니다. 아마 캐시 미스나, 컨텍스트 스위칭 등의 이유로 성능 차이가 나는 것 같습니다

[신입 개발자 면접 질문 모음](https://blog.naver.com/alice_k106/221566668266)

<br>

## CPU Affinity 란?

CPU affinity 란 SMP 시스템 상에서 프로세스를 주어진 CPU 세트에 제한 (bond) 할 수 있는 스케쥴러 속성입니다. 리눅스 스케쥴러는 적용된 CPU affinity 에 따라 프로세스가 지정된 CPU 외의 다른 CPU 에서 돌아가지 않도록 합니다.

[리눅스의 CPU Affinity](https://medium.com/@OutOfBedlam/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%9D%98-cpu-affinity-5df1a7ab3d99)
<br>

## Taskset 명령

taskset 명령을 사용하여 실행 중인 프로세스의 PID 로 CPU affinity 를 조회하거나 설정할 수 있습니다. 또한 명령을 실행할 때에서 CPU affinity 를 지정할 수도 있습니다. taskset 은 디폴트로 설치되지 않으므로 다음과 같이 schedutils 팩키지를 설치하여야 합니다.

CPU affinity 는 비트마스크로 표현되며, 가장 오른쪽 비트가 첫 번째 논리적인 CPU 를 표시합니다. 예를 들면 다음과 같습니다.

0x00000001 은 #0 프로세서입니다. (첫 번째 프로세서)
0x00000003 은 #0 과 #1 프로세서입니다.
0x00000004 은 #2 프로세서입니다. (세 번째 프로세서)

<br>

## 커넥션 풀과 쓰레드 풀의 차이

풀 (Pool) 이란 이미 사용할 준비가 된 자원을 메모리 위에 일정량 미리 생성해둔 자원의 집합으로

커넥션 풀은 DB 와 커넥션을 맺기 위한 드라이버를 로드하고 커넥션 객체를 생성하는 등의 과정에서 발생하는 비용을 절약할 수 있고,

쓰레드 풀은 쓰레드를 미리 생성해놓음으로써 쓰레드의 생성 및 수거가 빈번하게 발생하지 않아 메모리 할당에 소모되는 비용을 절약할 수 있습니다.

[커넥션, 쓰레드풀 차이 (인프런 질문)](https://www.inflearn.com/questions/819025/%EC%BB%A4%EB%84%A5%EC%85%98-%ED%92%80%EA%B3%BC-%EC%93%B0%EB%A0%88%EB%93%9C-%ED%92%80%EC%9D%98-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EB%A8%BC%EA%B0%80-%EA%B6%81%EA%B8%88%ED%95%A9%EB%8B%88%EB%8B%A4)

<br>

## Symmetric Multiprocessing (대칭형 멀티 프로세싱: SMP) 이란 무엇인가?

SMP 는 한 개 이상의 프로세서가 장착되고 각 프로세서에 부하를 똑같이 분배시킬 수 있는 운영체제가 구비된 컴퓨터 시스템을 설명하는데 사용되는 단어이다.

[SMP란 무엇인가?](http://www.dreamy.pe.kr/zbxe/CodeClip/163214#:~:text=Symmetric%20Multiprocessing%20(%EB%8C%80%EC%B9%AD%ED%98%95%20%EB%A9%80%ED%8B%B0%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1%20%3A%20SMP)%20%EC%9D%B4%EB%9E%80%20%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80,%ED%95%98%EB%8A%94%EB%8D%B0%20%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94%20%EB%8B%A8%EC%96%B4%EC%9D%B4%EB%8B%A4.)

<br>

## SQL 요청시 쿼리가 실행되는 과정에 대해 간략하게 설명해주세요

쿼리가 실행되는 과정은 3단계로 나눌 수 있습니다.
먼저, 요청된 SQL 문장을 토큰으로 분리해 파서트리를 만듭니다.
파서 트리를 기반으로 쿼리 문장의 구조적인 문제점을 확인하고, 옵티마이저에서 쿼리 문장을 효율적으로 처리하는 방법을 결정합니다.
실행엔진이 해당 내용을 전달해서 스토리지 엔진으로부터 데이터를 가져옵니다.
