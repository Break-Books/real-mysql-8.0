# 4.2.7 InnoDB 버퍼 풀

## 4.2.7.4 버퍼 풀 플러시
MySQL 8.0 버전 이후부터는 더티 페이지를 디스크로 동기화할 때 디스크 폭증 현상이 발생하지 않는다.

따라서 성능 문제가 발생하지 않는 상태라면 디스크 쓰기 동기화와 관련된 시스템 변수들을 조정할 필요는 없다.

InnoDB 스토리지 엔진은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 다음 2개의 플러시 기능을 백그라운드로 실행한다.


### 1. Flush_List 플러시
InnoDB 스토리지 엔진은 Flush_List 플러시 함수를 주기적으로 호출해서 더티페이지들을 디스크에 동기화한다.
이때, 변경된지 오래된 더티 페이지부터 순서대로 작업한다.

동기화 작업을 수행할 때 도움을 주는 시스템 변수들을 알아보자.
+ innodb_page_cleaners: 클리너 스레드 개수를 조정. 가능하면 innodb_buffer_pool_instances 설정값과 동일한 값으로 설정하자.
+ innodb_max_dirty_pages_pct: 더티 페이지의 비율을 조정. 가능하면 기본값을 유지하자.
+ innodb_io_capacity: 디스크가 더티 페이지를 처리할 수 있는 수준의 값을 설정.
+ innodb_adaptive_flushing: 리두 로그의 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼 풀에 유지될 수 있도록 함
+ innodb_flush_neighbors: 더티 페이지를 디스크에 기록할 때 근접한 페이지 중 더티 페이지가 있다면 함께 디스크에 기록하는 기능. 기본값인 비활성 모드로 유지하자.

### 2. LRU_List 플러시
InnoDB 스토리지 엔진은 LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들어야 하는데, 이를 위해 LRU_list 플러시 함수가 사용된다.

## 4.2.7.5 버퍼 풀 상태 백업 및 복구
디스크의 데이터가 버퍼 풀에 적재돼 있는 상태를 워밍업이라고 한다.

버퍼 풀이 잘 워밍업 된 상태에서는 그렇지 않은 경우보다 몇십 배의 쿼리 처리 속도를 보이는 것이 일반적이다.

그래서 MySQL 5.5 버전에서는 강제 워밍업을 위해 주요 테이블과 인덱스를 풀 스캔했었다.

하지만 MySQL 5.6 버전부터는 버퍼 풀 덤프 및 적재 기능이 도입됐다. 환경 변수를 통해 현재 InnoDB 버퍼 풀의 상태를 백업하고 복구할 수 있다.

```sql
-- // MySQL 서버 셧다운 전에 버퍼 풀의 상태 백업
mysql> SET GLOBAL innodb_buffer_pool_dump_now=ON;

-- // MySQL 서버 재시작 후, 백업된 버퍼 풀의 상태 복구
mysql> SET GLOBAL innodb_buffer_pool_load_now=ON;
```

버퍼 풀의 백업은 버퍼 풀의 LRU 리스트에서 적재된 데이터 페이지의 메타 정보만 가져와서 저장하기 때문에 매우 빨리 완료된다.

하지만 버퍼 풀 복구는 백업 메타 정보를 통해 디스크에서 읽어오는 과정이므로 시간도 많이 소요되고 크기도 상당하다. 따라서 InnoDB 스토리지 엔진은 복구 과정이 어느 정도 진행됐는지 알 수 있는 상태 값을 제공한다.

## 4.2.7.6 버퍼 풀의 적재 내용 확인
InnoDB 버퍼 풀이 큰 경우 버퍼 풀의 상태를 확인하는 것이 어려운 문제점을 해결하기 위해 MySQL 8.0에서는 innodb_cached_indexes 테이블을 추가했다.

이 테이블을 이용해 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인할 수 있다.