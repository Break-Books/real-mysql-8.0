# 9.2.3 ORDER BY 처리(Using filesort)

정렬을 처리하는 방법은 index를 이용하는 방법과 filesort를 이용하는 방법으로 나뉜다.

파일소트

- 장점
  - 인덱스를 이용하지 않는다.
  - 레코드가 적으면 메모리에서 정렬되므로 빠르다.
- 단점
  - 느리다.

파일소트를 사용해야만 하는 경우

- 정렬 기준이 너무 많아서 요건 별로 인덱스를 생성하는 것이 불가능한 경우
- group by 혹은 distinct 같은 처리의 결과를 정렬해야 하는 경우
- union 의 결과 같이 임시 테이블의 결과를 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

## 9.2.3.1 소트 버퍼

정렬을 수행하기 위해 별도의 메모리 공간을 할당받는데, 이 공간을 소트 버퍼라고 한다.

가변적이지만, `sort_buffer_size`라는 시스템 변수로 설정할 수 있다.

정렬이 문제가 되는 이유: 정렬해야 할 레코드 건수가 소트 버퍼로 할당된 공간보다 크다면?

여러 조각으로 나눠서 해결한다.

정렬을 수행하고, 임시로 디스크에 기록하고, 레코드를 가져오고, 다시 정렬하고, 반복적으로 디스크에 임시 저장한다. **Multi-merge**라고 한다.

**소트 버퍼를 크게 설정하면 디스크를 사용하지 않아서 더 빨라질 것 같지만 실제 벤치마크 결과는 큰 차이를 보이지 않는다.**

> 그렇다면 소트 버퍼를 엄청 작은 값으로 설정하면...?

소트 버퍼 크기가 256kb에서 8mb 사이로 설정되었을 때 최적의 성능을 보였으며, 그 미만 혹은 이상 부터는 소트 버퍼 크기 변화에 대해 성능 효과가 보이지 않았다.

- 너무 큰 sort_buffer_size 를 사용하는 경우, 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수도 있다.

---

소트 버퍼는 세션 메모리 영역에 해당한다. 즉 소트 버퍼는 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니다. 커넥션이 많으면 많을수록, 정렬 작업이 많으면 많을수록 소트 버퍼 메모리 공간이 커진다.

소트 버퍼 크기가 10MB 이상이면 대량의 레코드를 정렬하는 쿼리가 여러 커넥션에서 동시에 실행되면서 운영체제 메모리 부족 현상을 겪을 수 있다.

> 디스크의 IO 성능이 낮은 장비라면 소트 버퍼의 크기를 크게 설정하면 도움이 될 수 있다.

질문:

- 소트 버퍼를 너무 크게 했을 때 생기는 문제점
- 소트 버퍼를 너무 작게 했을 때 생기는 문제점

## 9.2.3.2 정렬 알고리즘

- 싱글 패스: 레코드 전체를 소트 버퍼에 담는다.
- 투 패스: 정렬 기준 칼럼만 소트 버퍼에 담는다.

```sql
SET OPTIMIZER_TRACE="enabled=on", END_MARKERS_IN_JSON=on;
SET OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;

SELECT * FROM employees ORDER BY last_name;

SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE \G
```

```
"sort_algorithm": "std::stable_sort"
```

```
"sort_mode": <fixed_sort_key, packed_additional_fields>
```

소트 모드

```
<sort_key, rowid>: 정렬 키와 레코드의 로우 아이디만 가져와서 정렬
<sort_key, additional_fields>: 전체를 가져와서 정렬, 레코드 칼럼은 고정 사이즈로 메모리 저장.
<sort_key, packed_additional_fields>: 전체를 가져와서 정렬, 레코드 칼럼은 가변 사이즈로 메모리 저장
```

첫 번째가 투 패스이고 두, 세 번째가 싱글패스이다.

### 싱글 패스 정렬 방식

소트 버퍼에 정렬 기준 컬럼을 포함해 SELECT 대상이 되는 컬럼 전부를 담아서 정렬을 수행하는 정렬 방식

### 투 패스 정렬 방식

정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 컬럼을 가져오는 정렬 방식

### 싱글 패스 vs 투 패스

투 패스 정렬 방식은 테이블을 두 번 읽어야 하기 때문에 불합리해서 일반적으로 싱글 패스를 사용한다.

하지만 싱글 패스 정렬은 많은 소트 버퍼 공간이 필요하기 때문에, 다음 조건에서는 해당 정렬 방식을 사용한다.
- 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
- BLOB이나 TEXT 타입의 컬럼이 SELECT 대상에 포함될 때

성능에 관해서는 다음과 같은 차이점을 보인다.
- 싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보인다.
- 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이다.

## 정렬 처리 방법

쿼리에 ORDER BY가 사용되면 3가지 중 하나로 정렬이 처리된다. 아래로 갈수록 처리 속도는 떨어진다.

- 인덱스를 사용한 방법: 실행 계획의 Extra 컬럼에 별도 표기 없음
- 조인에서 드라이빙 테이블만 정렬: "Using filesort" 메세지 표시됨
- 조인에서 조인 결과를 임시 테이블로 저장 후 정렬: "Using temporary; Using filesort" 메세지 표시됨

### 인덱스를 이용한 정렬

반드시 ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블(드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
인덱스를 이용한 정렬이 처리되는 경우, 실제 인덱스 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 된다.

### 조인의 드라이빙 테이블만 정렬

일반적으로 조인이 수행되면 결과 레코드의 건수가 몇 배로 불어나기 때문에, 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책이 된다.
그러려면 드라이빙 테이블의 컬럼만으로 ORDER BY 절을 작성해야 한다.
