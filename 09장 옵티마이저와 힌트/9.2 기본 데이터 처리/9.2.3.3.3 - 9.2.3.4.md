# 9.2.3.3.3 - 9.2.3.4

## 9.2.3.3 정렬 처리 방법

### 9.2.3.3.1 인덱스를 이용한 정렬

바로 앞 문서 참고 (영현님)

### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬

바로 앞 문서 참고 (영현님)

### 9.2.3.3.3 임시 테이블을 이용한 정렬

우선 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다.

**가장 느린 정렬 방법**이다.

```sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
AND e.emp_no BETWEEN 100002 AND 100010
ORDER BY s.salary;
```

이 쿼리는 정렬 기준 칼럼이 드라이빙 테이블이 아니라 드리븐 테이블에 있는 칼럼이다. 정렬이 수행되기 전에 salaries 테이블을 읽어야 하므로 임시 테이블을 가지고 정렬하는 수밖에 없다.

```
Using where; Using temporary; Using filesort
```

### 9.2.3.3.4 정렬 처리 방법의 성능 비교

LIMIT이 거의 필수로 함께 사용된다. 그런데 ORDER BY나 GROUP BY는 WHERE 조건을 만족하는 레코드를 LIMIT 건수만큼만 가져와서 처리할 수는 없다.

왜 느리게 작동할 수 밖에 없을까? 쿼리가 처리되는 2가지 방법에 대해 살펴보자.

#### 9.2.3.3.4.1 스트리밍 방식

서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드를 바로바로 클라이언트에 전송해주는 방식이다.

**가장 빠른 응답 시간을 보장해준다.**

서버에서 쿼리가 아직 실행되고 있는 도중이라도 첫 데이터는 보내준다.

마지막 데이터가 언제 전송될 것인지는 알 수 없다.

#### 9.2.3.3.4.2 버퍼링 방식

서버가 모든 레코드를 검색하고 정렬하고 난 뒤에 클라이언트에 보내주는 방식이다.

ORDER BY나 GROUP BY는 결과가 스트리밍 되는 것이 불가능하다. 일단 정렬을 해야 알 수 있기 때문이다.

서버가 정렬하는 동안 클라이언트는 그저 기다려야 한다. 응답 속도가 느려진다. 이런 경우에는 물론 LIMIT을 쓰면 네트워크로 전송되는 레코드 건수를 줄일 수는 있으나, 서버 작업량에는 변화가 그다지 없고, TTFB (time to first byte)도 느릴 것이다.

> 참고: MySQL Server는 기본값이 스트리밍 방식이지만 JDBC는 **버퍼링 방식**이다. 전체 처리 (쓰루풋) 시간이 짧고 통신 횟수가 적고 자원 소모가 줄기 때문이다. 대량의 데이터를 불러와야 할때는 JDBC의 전송방식을 스트리밍 방식으로 변경하면 된다.

- 인덱스를 이용한 정렬
- 조인의 드라이빙 테이블만 정렬
- 임시 테이블을 이용한 정렬

이 세 가지 처리 방법 가운데 인덱스를 이용한 정렬 방식만이 스트리밍 형태로 동작한다.

즉,

- 인덱스를 사용할 수 있다면 스트리밍
- 인덱스를 사용하지 못하면 버퍼링

> 참고: **LIMIT이 아예 도움이 되지 않는 것은 아니고**, 상위 n개가 정렬이 채워지면 정렬을 멈추고 반환하도록 최적화되어 있지만, 이를 위해 퀵 소트 혹은 힙 소트 알고리즘을 사용한다. 인덱스를 사용하지 못한다면 **LIMIT이 5-10건만 되어도 속도가 기대만큼 빠르지는 않다.**

### 9.2.3.4 정렬 관련 상태 변수

몇 건의 정렬 처리를 수행했는지, 소트 버퍼 간의 병합 작업은 몇 번 발생했는지를

```
FLUSH STATUS; SHOW STATUS LIKE 'Sort%';
```

로 확인해볼 수 있다.

```
Sort_merge_passes: 멀티 머지 처리 횟수
Sort_range: 인덱스 레인지 스캔을 통한 정렬 작업 횟수
Sort_rows: 지금까지 정렬한 전체 레코드 건수
Sort_scan: 풀 테이블 스캔을 통한 정렬 작업 횟수
```

책 예제를 보면
값들이 각각

- 13
- 0
- 300024
- 1

인데, 이를 통해 다음을 유추할 수 있다.

- 풀 테이블 스캔의 결과를 1번 정렬
- 13번 병합 처리
- 300024 레코드 정렬
