# 5.3.1 InnoDB 스토리지 엔진의 잠금

## 개요
InnoDB 스토리지 엔진은 MySQL과 별개로 잠금을 제공
- 스토리지 엔진 내부에서 레코드 기반 잠금 방식 탑재
- 뛰어난 동시성 처리 가능

<br>

![](https://velog.velcdn.com/images/hellojihyoung/post/fed94b7e-95a2-4936-9ec8-c96b736f424a/image.png)

- InnoDB 스토리지 엔진은 **레코드 기반의 잠금** 을 제공한다.
  - 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 락 에스컬레이션되는 경우는 없다.
- 레코드와 레코드 사이의 간격을 잠그는 갭(GAP) 락이라는 것이 존재한다.

#### *락 에스컬레이션 : 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우

<br>

## 5.3.1.1 레코드 락
**레코드 락 : 레코드 자체만을 잠그는 것**
- InnoDB 스토리지 엔진은 레코드 자체가 아니라, `인덱스의 레코드`를 잠근다.
- 인덱스가 없는 테이블의 경우 내부적으로 자동 생성된 인덱스의 레코드를 잠근다.

<br>

## 5.3.1.2 갭 락
**갭 락 : 레코드를 잠그는게 아닌, 레코드와 인접한 레코드 사이의 간격(갭)을 잠그는 것**
- 새로운 레코드가 생성되지 않도록 하기 위해 설정한다.
- 갭 락은 넥스트 키 락의 일부로 자주 사용된다.

<br>

## 5.3.1.3 넥스트 키 락
**넥스트 키 락 : 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금**

- `innodb_locks_unsafe_for_binlog` 시스템 변수가 비활성화되면(0으로 설정) 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸린다. 
- 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
  - 데드락이나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다. 
    - 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 키락을 줄이는 것이 좋다.
    - 레플리카 서버를 사용하지 않는다면 사용을 지양하라.
  
<br>

## 5.3.1.4 자동 증가 락
MySQL에서는 자동 증가하는 숫자 값을 추출(채번)하기 위해 `AUTO_INCREMENT`라는 컬럼 속성을 제공한다.

자동 증가 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 한다. InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 자동 증가 락이라고 하는 테이블 수준의 잠금을 사용한다.

- `AUTO_INCREMENT` 락은 `INSERT`와 `REPLACE` 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하며, `UPDATE`, `DELETE` 쿼리에서는 걸리지 않는다.
- 트랜잭션 관계 없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간에만 락이 걸렸다가 즉시 해제된다.
- 시스템 변수를 이용하여 자동 증가 락의 작동 방식을 변경할 수 있다.
  - innodb_autoinc_lock_mode = 0
    - 모든 INSERT 문장은 자동 증가 락을 사용한다.
  - innodb_autoinc_lock_mode = 1
    - 단순한 1건 또는 여러건의 레코드를 MySQL 서버가 레코드의 건수를 정확하게 예측할 수 있는 경우에는 자동 증가 락을 사용하지 않고 래치(뮤텍스)를 이용해 처리한다.
  - innodb_autoinc_lock_mode = 2
    - 자동 증가 락을 사용하지 않고, 래치(뮤텍스)를 사용한다. 동시 처리 성능이 향상되지만, 연속된 자동 증가 값을 보장하지 않는다.
- `AUTO_INCREMENT` 잠금을 최소화 하기 위해 자동 증가한 값이 한 번 증가하면 줄어들지 않는다.