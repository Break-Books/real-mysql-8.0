# 10.1.2 히스토그램

MySQL 5.7 버전까지 통계 정보는 단순히 인덱스된 컬럼의 유니크한 값의 개수만 가지고 있었다.
MySQL 8.0 버전부터는 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 되었다.

## 10.1.2.1 히스토그램 정보 수집 및 삭제

MySQL 8.0에서는 칼럼 단위로 히스토그램 정보가 관리된다.

+ 이를 수집하기 위해서는 ANALYZE TABLE ... UPDATE HISTOGRAM 명령을 실행해야 한다.

information_schema 데이터베이스의 column_statistics 테이블을 select 해보면 히스토그램 정보를 확인할 수 있다.

MySQL 8.0 버전에서는 다음과 같이 2종류의 히스토그램 타입이 지원된다.

+ Singleton(싱글톤 히스토그램) : 칼럼값 개별로 레코드 건수를 관리하는 히스토그램, Value-Based 히스토그램 또는 도수 분포라고도 불린다.
+ Equi-height(높이 균형 히스토그램) : 칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램, Height-Balanced 히스토그램이라고도 불린다.

MySQL 8.0.19 미만의 버전까지는 풀 스캔을 통해 데이터 페이지를 샘플링해서 히스토그램을 생성했다.
하지만 MySQL 8.0.19 버전부터 InnoDB 스토리지 엔진 자체적으로 샘플링 알고리즘을 구현했으며, 더이상 히스토 그램 수집 시 풀 테이블 스캔이 필요치 않게 됐다.

## 10.1.2.2 히스토그램의 용도

원래 통계 정보는 전체 레코드 건수와 인덱스된 칼럼이 가지는 유니크한 값의 개수 정도였다.

하지만 데이터는 항상 균등한 분포도를 가지지 않는다.

히스토그램이 없을 때와 있을 때의 예측치가 매우 달라진다.

```sql
EXPLAIN
SELECT *
FROM employees
WHERE first_name='Zita'
AND birth_date BETWEEN '1950-01-01' AND '1960-01-01';
```

```sql
ANALYZE TABLE employees
UPDATE histogram ON first_name, birth_name;
```

예제 코드는 달라지지 않았으나 옵티마이저 힌트를 이용해서 성능을 바꾼 듯 하다.

조인 순서에 따라 쿼리의 성능이 달라진다는 것을 강조한 예시이다.

employees의 컬럼이 salaries 테이블보다 조인할 건수가 훨씬 적어서, 먼저 조인되면 성능이 더 빠르다.

## 10.1.2.3 히스토그램과 인덱스

```sql
SELECT *
FROM employees
WHERE first_name='Tonny'
AND birth_date BETWEEN '1954-01-01' AND '1955-01-01';
```

옵티마이저는 테이블 풀 스캔을 할지 first_name 칼럼의 인덱스를 이용할지 고민한다.

### 인덱스 다이브

조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저가 실제 인덱스의 b-tree를 살펴본다.

히스토그램보다 더 정확한 결과를 기대할 수 있다.

IN 절에 값이 많이 명시되어 있는 경우 어느 정도의 비용이 필요하기 때문에, 인덱스 다이브 vs. 히스토그램 사이의 최적화도 조만간 추가되지 않을까 한다 (라고 책에 적혀 있다).
