# 10.1.3 코스트 모델

MySQL 서버는 최적의 실행 계획을 찾는다. 전체 쿼리의 비용을 계산하는 데에 사용되는 요소들을 Cost Model이라고 한다.

5.7 이전버전까지는 상수화되어 있었지만, 하드웨어에 따라 달라질 수 있다.

5.7 버전부터는 DBMS 관리자가 조정할 수 있게 개선되었으나 여전히 많은 정보가 부족했다.

8.0 부터는 히스토그램과 인덱스별 메모리 적재된 페이지 비율이 관리되고 실행 계획에 사용되기 시작했다.

이 코스트 모델은 다음 2개 테이블에 저장되어 있는 설정 값들을 사용한다.

- server_cost: 인덱스를 찾고 레코드를 비교하고 임시 테이블에 대한 비용 관리
- engine_cost: 레코드를 가진 데이터 페이지를 가져오는 데에 필요한 비용 관리

위 테이블은 공통으로 5개의 칼럼을 가지고 있다.

- cost_name: 코스트 모델의 단위 작업
- default_value: 단위 작업의 비용 기본값
- cost_value:  DBMS 관리자가 설정한 값
- last_updated: 단위 작업의 비용이 변경된 시점
- comment: 추가 설명

engine_cost 컬럼은 추가로 2개를 더 가지고 있다.

- engine_name: 비용이 적용된 스토리지 엔진
- device_type: 디스크 타입. MySQL 8.0 에서는 사용되지 않는다.

row_evaluate_cost 값이 증가할수록 풀 테이블 스캔과 같이 많은 레코드를 처리하는 쿼리의 비용이 높아지고 적은 수의 레코드를 처리하는 쿼리의 비용이 낮아진다.

key_compare_cost는 키 값의 비교 작업에 필요한 비용을 의미한다. 이 값이 증가할 수록 키 값의 비교 처리가 많을 경우 비용이 높아진다.

## Cost 확인하는 방법

```sql
EXPLAIN FORMAT=TREE
SELECT *
FROM employees WHERE first_name='Matt' \G
```

## 외워야 할 사항들

### key_compare_cost 비용을 높이면?

서버는 정렬을 수행하지 않는 방향의 실행 계획을 선호한다.

### row_evaluate_cost 비용을 높이면?

풀 스캔을 실행하는 쿼리의 비용이 높아지고, 가능하면 인덱스 레인지 스캔을 사용한다.

### disk_temptable_create_cost 와 dist_temptable_row_cost 비용을 높이면?

디스크에 임시 테이블을 만들지 않는 방향으로

### memory_temptable_

메모리에 임시 테이블을 만들지 않는 방향으로

### io_block_read_cost 비용이 높아지면?

버퍼 풀에 데이터 페이지가 이미 많이 적재되어 있는 인덱스를 사용하는 실행 계획을 선택할 가능성이 높다.

### memory_block_read_cost 비용이 높아지면?

적재된 데이터 페이지가 상대적으로 적다고 하더라도 그 인덱스를 사용할 가능성이 높아진다.

> 주의: 전문적인 지식을 가지고 있는게 아니라면 기본값을 함부로 변경하지 않는 것이 좋다.
