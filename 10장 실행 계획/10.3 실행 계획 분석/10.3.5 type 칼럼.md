# 10.3.5 type 칼럼



테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.



**MySQL의 매뉴얼에서는 '조인 타입'으로 소개되었지만, 접근 방법이라고 생각하는 것을 추천한다!!!!**



- system

- const

- eq_ref

- ref

- fulltext

- ref_or_null

- unique_subquery

- index_subquery

- range

- index_merge

- index

- ALL



등이 있다.



ALL을 제외하면 모두 인덱스를 사용하는 접근 방법이다.

index_merge를 제외한 나머지 접근 방법은 인덱스를 하나만 사용한다.

****

**성능이 빠른 순서대로 나열된 것이다.**



## 10.3.5.1 system

레코드가 1건만 존재하는 테이블, 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법을 system이라고 한다.

MyISAM이나  MEMORY 테이블에서만 사용되는 접근 방법이다.

```sql
create table tb_dual (fd1 int not null) engine=myisam;
insert into tb_dual values (1);

explain select * from tb_dual;
```

> 1 simple tb_dual system 1 null

이 테이블을 innoDB로 변환하면?

```sql
create table tb_dual (fd1 int not null) engine=innodb;
insert into tb_dual values (1);
explain select * from tb_dual;
```

> 1 simple tb_dual all 1 null

쿼리의 모양에 따라 조금은 다르겠지만 접근 방법이 ALL 또는 index로 표시될 가능성이 크다.

system은 테이블에 레코드가 1건 이하인 경우에만 사용할 수 있는 접근 방법으로 실제 어플리케이션에서 사용되는 쿼리에서는 거의 보이지 않는 실행 계획이다.

## const

레코드 건수와 관계 없이 쿼리가 primary key나 unique key column을 이용하는 where 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식을 const 라고 한다.

unique index scan이라고 표현하기도 한다.

```sql
explain
select * from employees where emp_no=10001;


1 simple employees const primary 4
```

primary key의 일부만 조건으로 사용될 때에는 const가 아닌 ref로 표시된다.

### 질문: 왜 const를 쓸까요?

실행 계획의 type 컬럼이 const인 실행 계획은 MySQL의 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해서 통째로 상수화한다.

```sql
explain
select count(*)
from employees e1
where first_name=(select first_name from employees e2 where emp_no=10001);
```

위 예제에서 where 절에 사용된 서브 쿼리는 상수로 고정된다.

```sql
select count(*)
from employees e1
where first_name='Jasminko';
```

위 쿼리로 변환된다.
