# 10.3.5 type 칼럼



테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.



**MySQL의 매뉴얼에서는 '조인 타입'으로 소개되었지만, 접근 방법이라고 생각하는 것을 추천한다!!!!**



- system

- const

- eq_ref

- ref

- fulltext

- ref_or_null

- unique_subquery

- index_subquery

- range

- index_merge

- index

- ALL



등이 있다.



ALL을 제외하면 모두 인덱스를 사용하는 접근 방법이다.

index_merge를 제외한 나머지 접근 방법은 인덱스를 하나만 사용한다.

****

**성능이 빠른 순서대로 나열된 것이다.**



## 10.3.5.1 system

레코드가 1건만 존재하는 테이블, 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법을 system이라고 한다.

MyISAM이나  MEMORY 테이블에서만 사용되는 접근 방법이다.

```sql
create table tb_dual (fd1 int not null) engine=myisam;
insert into tb_dual values (1);

explain select * from tb_dual;
```

> 1 simple tb_dual system 1 null

이 테이블을 innoDB로 변환하면?

```sql
create table tb_dual (fd1 int not null) engine=innodb;
insert into tb_dual values (1);
explain select * from tb_dual;
```

> 1 simple tb_dual all 1 null

쿼리의 모양에 따라 조금은 다르겠지만 접근 방법이 ALL 또는 index로 표시될 가능성이 크다.

system은 테이블에 레코드가 1건 이하인 경우에만 사용할 수 있는 접근 방법으로 실제 어플리케이션에서 사용되는 쿼리에서는 거의 보이지 않는 실행 계획이다.

## const

레코드 건수와 관계 없이 쿼리가 primary key나 unique key column을 이용하는 where 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식을 const 라고 한다.

unique index scan이라고 표현하기도 한다.

```sql
explain
select * from employees where emp_no=10001;


1 simple employees const primary 4
```

primary key의 일부만 조건으로 사용될 때에는 const가 아닌 ref로 표시된다.

### 질문: 왜 const를 쓸까요?

실행 계획의 type 컬럼이 const인 실행 계획은 MySQL의 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해서 통째로 상수화한다.

```sql
explain
select count(*)
from employees e1
where first_name=(select first_name from employees e2 where emp_no=10001);
```

위 예제에서 where 절에 사용된 서브 쿼리는 상수로 고정된다.

```sql
select count(*)
from employees e1
where first_name='Jasminko';
```

위 쿼리로 변환된다.


## ref

인덱스 종류와 관계 없이 동등 조건으로 검색할 때 ref 접근 방법이 사용된다.     
ref 접근 방법은 eq_ref와는 달리 조인의 순서와 관계없이 사용되며, 프라이머리 키나 유니크 키 등의 제약 조건도 없다.   

ref 타입은 반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const나 eq_ref보다는 빠르지 않다. 하지만 동등한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법의 하나다.    

```sql
explain
select * from dept_emp where dept_no='d005';
```

## 실행 계획 type 비교 

+ **const**: 조인의 순서와 관계없이 프라이머리 키나 유니크 키의 모든 칼럼에 대해 동등(Equal) 조건으로 검색(반드시 1건의 레코드만 반환)
+ **eq_req**: 조인에서 첫 번째 읽은 테이블의 칼럼값을 이용해 두 번째 테이블을 프라이머리 키나 유니크 키로 동등 조건으로 검색
+ **ref**: 조인의 순서와 인덱스의 종류에 관계없이 동등 조건으로 검색
+ **fulltext**: MySQL의 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법
+ **ref_or_null**: ref 접근 방식과 같은데, NULL 비교가 추가된 형태
+ **unique_subquery**: WHERE 조건 절에서 IN(서브쿼리) 형태의 쿼리를 위한 접근 방법
+ **index_subquery**: 쿼리가 유니크한 값을 반환하지 않는데, 사용한 인덱스를 이용해 중복 값을 제거할 수 있는 경우
+ **range**: 인덱스 레인지 스캔 형태의 접근 방법 
+ **index_merge**: 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식
+ **index**: 인덱스 풀 스캔을 의미하는 접근 방법
+ **ALL**: 풀 테이블 스캔을 의미하는 접근 방법 
