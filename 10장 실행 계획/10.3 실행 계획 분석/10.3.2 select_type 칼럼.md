# 10.3.2 select_type 칼럼

**단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼**

### 10.3.2.1 SIMPLE
**UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우**
쿼리 문장이 아무리 복잡해도 실행 계획에서 select_type이 SIMPLE인 단위 쿼리는 **하나만 존재**한다. 일반적으로 제일 바깥 SELECT 쿼리의 select_type이 SIMPLE로 표시된다.

<br>

### 10.3.2.2 PRIMARY
**UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리의 경우**
SIMPLE과 마찬가지로 **하나만 존재** 하며, 쿼리의 제일 바깥쪽에 있는 SELECT 단위 쿼리가 PRIMARY로 표시된다.

<br>

### 10.3.2.3 UNION
**UNION으로 결합하는 단위 SELECT 쿼리 중 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 경우**

첫 번째 단위 SELECT는 쿼리 결과를 모아서 저장하는 `임시 테이블(DERIVED)`로 표시된다.

* 420쪽 예시

<br>

### 10.3.2.4 DEPENDENT UNION
**UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미**

즉, 내부 쿼리가 외부의 값을 참조해서 처리될 떄 DEPENDENT 키워드가 표시된다.

<br>

### 10.3.2.5 UNION RESULT
**UNION 결과를 담아두는 테이블을 의미**
MySQL 8.0 이전 버전에서는 UNION의 결과를 임시 테이블로 생성했는데, MySQL 8.0부터는 UNION ALL인 경우 임시 테이블을 사용하지 않도록 기능이 개선됐다. 하지만 UNION은 여전히 임시 테이블에 결과를 버퍼링한다.

실행 계획상에서 임시 테이블을 가리키는 라인의 select_type이 UNION RESULT이며, 단위 쿼리가 아니기 때문에 별도의 id 값은 부여되지 않는다.

<br>

### 10.3.2.6 SUBQUERY
**FROM 절 이외에서 사용되는 서브쿼리를 의미**
FROM 절에 사용된 서브쿼리는 DERIVED(파생 테이블)로 표시되고, 그 밖의 위치에서 사용된 서브쿼리는 전부 SUBQUERY로 표시된다.

<br>

### 10.3.2.7 DEPENDENT SUBQUERY
**서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 컬럼에 의존적인 경우 DEPENDENT SUBQUERY가 표시**
안쪽 서브쿼리 결과가 바깥쪽 SELECT 쿼리의 컬럼에 의존적이므로 DEPENDENT 키워드가 붙는다.
또한 DEPENDENT SUBQUERY는 외부 쿼리가 먼저 수행된 후 내부 쿼리가 실행돼야 하므로 일반 서브쿼리보다 처리 속도가 느릴 때가 많다.

<br>

### 10.3.2.8 DERIVED
**단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블(파생 테이블)을 생성하는 것을 의미**
MySQL 5.5 버전까지는 서브쿼리가 FROM 절에 사용된 경우 항상 DERIVED(파생 테이블)을 만들었기 때문에 성능상 불리한 점이 많았지만, MySQL 5.6 버전부터는 옵티마이저 옵션에 따라 쿼리 특성에 맞게 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화됐다.

가능하면 DERIVED 형태의 실행 계획을 조인으로 해결할 수 있게 쿼리를 변경하는 것이 좋다. MySQL 8.0부터는 FROM 절의 서브쿼리 최적화도 많이 개선되어 불필요한 서브쿼리를 조인으로 재작성하는 최적화를 지원하지만, 옵티마이저의 처리 능력에도 한계가 있으므로 최적화된 쿼리를 작성하는 것은 매우 중요하다.

*쿼리 튜닝을 위해 실행 계획을 분석한다면 select_type 컬럼이 DERIVED인 것을 먼저 확인하고 제거하자.
또한, 서브쿼리를 조인으로 해결할 수 있는 경우 조인을 사용하는 것을 강력히 권장한다.*

<br>

### 10.3.2.9 DEPENDENT DERIVED
MySQL 8.0 이전 버전에서는 FROM 절의 서브쿼리는 외부 컬럼을 사용할 수 없었는데, MySQL 8.0 부터는 래터럴 조인 기능이 추가되면서 FROM 절의 서브쿼리에서도 외부 컬럼을 참조할 수 있게 됐다. 래터럴 조인을 사용하면 select_type 컬럼이 DEPENDENT DERIVED 키워드가 표시된다.

<br>

### 10.3.2.10 UNCACHEABLE SUBQUERY
조건이 똑같은 서브쿼리가 실행될 때는 쿼리를 다시 실행하지 않고 이전의 실행 결과를 내부적인 캐시 공간에 담아두고 재사용하게 된다. 하지만 **서브쿼리에 포함된 요소에 의해 캐시 자체가 불가능한 경우 select_type이 UNCACHEABLE SUBQUERY로 표시된다.**

### SUBQUERY
- 한 번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용한다.
### DEPENDENT SUBQUERY
- 의존하는 바깥쪽 쿼리의 컬럼 값 단위로 캐시해두고 사용한다.

### 캐시를 사용하지 못하게 하는 요소
- 사용자 변수가 서브쿼리에 사용된 경우
- NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리내에 사용된 경우
- UUID(), RAND() 같은 결과값이 호출할 때마다 달라지는 함수가 서브쿼리에 사용된 경우

<br>

### 10.3.2.11 UNCACHEABLE UNION
**UNION 수행 시 포함된 요소에 의해 캐시가 불가능한 경우 select_type이 UNCACHEABLE UNION로 표시**

<br>

### 10.3.2.12 MATERIALIZED
MySQL 5.6 버전부터 도입되었으며, **주로 FROM 절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용**

MySQL 5.6 버전까지는 테이블을 읽어서 레코드마다 다른 테이블을 읽는 서브쿼리가 실행되는 형태로 처리
하지만 MySQL 5.7 버전부터는 서브쿼리의 내용을 임시 테이블로 구체화(Materialization)한 후, 임시 테이블과 employees 테이블을 조인하는 형태로 최적화되어 처리
